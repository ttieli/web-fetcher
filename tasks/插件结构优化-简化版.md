# Web Fetcher Personal Tool Plugin Architecture (Simplified)
# Web Fetcher 个人工具插件架构（简化版）

## Core Philosophy
## 核心理念

**This is a personal tool, not enterprise software.**  
**这是个人工具，不是企业软件。**

- Pragmatic > Perfect / 实用 > 完美
- Simple > Complete / 简单 > 完备  
- Working > Elegant / 能用 > 优雅
- Fast Implementation > Future-proof / 快速实现 > 未来保证

## 1. Current State Summary (What We Have)
## 1. 现状总结（我们有什么）

### Core Components
### 核心组件
- `webfetcher.py`: 5298 lines monolithic file / 5298行单体文件
- Built-in urllib: Core method, always works / 核心方法，始终工作
- Curl fallback: For SSL issues / SSL问题回退
- Playwright: JavaScript rendering (heavy) / JavaScript渲染（重）
- Safari: macOS-specific extraction / macOS特定提取

### What Works Well
### 工作良好的部分
- urllib handles 80% of cases / urllib处理80%情况
- Existing retry logic is solid / 现有重试逻辑稳固
- Current API is simple and clear / 当前API简单清晰

### Real Problems
### 实际问题
- Hard to fix SSL issues / 难以修复SSL问题
- Safari code scattered everywhere / Safari代码散布各处
- Can't easily add new fetchers / 不能轻松添加新获取器

## 2. Ultra-Simplified Target Architecture
## 2. 超简化目标架构

### Design Principles (Personal Tool Version)
### 设计原则（个人工具版）

1. **Static imports only** - No dynamic plugin discovery / **仅静态导入** - 无动态插件发现
2. **Simple Python config** - Just dictionaries, no YAML / **简单Python配置** - 仅字典，无YAML
3. **Basic error handling** - try/except, that's it / **基础错误处理** - try/except足矣
4. **No sandboxing** - It's your own code / **无沙盒** - 这是你自己的代码
5. **Minimal abstraction** - 1-2 layers max / **最小抽象** - 最多1-2层

### Simplified Architecture
### 简化架构

```
webfetcher.py (main entry)
    ├── urllib (built-in, always available)
    └── plugins/ (optional methods)
         ├── curl.py     (SSL fallback)
         ├── playwright.py (JS rendering)
         └── safari.py   (macOS special)
```

### Minimal Plugin Interface
### 最小插件接口

```python
# plugins/base.py - That's ALL you need!
# plugins/base.py - 这就是你需要的全部！

class SimplePlugin:
    """Dead simple plugin interface"""
    """极简插件接口"""
    
    def __init__(self, name):
        self.name = name
        self.enabled = True
    
    def can_fetch(self, url):
        """Can this plugin fetch this URL?"""
        """这个插件能获取这个URL吗？"""
        return True  # Override in subclass
    
    def fetch(self, url, timeout=30):
        """Fetch the URL, return (success, content, error)"""
        """获取URL，返回 (成功, 内容, 错误)"""
        raise NotImplementedError
```

## 3. Implementation Plan (3 Weeks Total)
## 3. 实施计划（总计3周）

### Week 1: Curl Plugin (3 days)
### 第1周：Curl插件（3天）

**Day 1-2: Extract and simplify**
**第1-2天：提取和简化**

```python
# plugins/curl_plugin.py - Direct and simple
# plugins/curl_plugin.py - 直接简单
import subprocess
from plugins.base import SimplePlugin

class CurlPlugin(SimplePlugin):
    def __init__(self):
        super().__init__('curl')
        
    def can_fetch(self, url):
        # Always available as fallback
        # 始终可用作回退
        return url.startswith(('http://', 'https://'))
    
    def fetch(self, url, timeout=30):
        try:
            cmd = ['curl', '-L', '--insecure', '--max-time', str(timeout), url]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout)
            
            if result.returncode == 0:
                return True, result.stdout, None
            else:
                return False, None, result.stderr
        except Exception as e:
            return False, None, str(e)
```

**Day 3: Integration**
**第3天：集成**

```python
# In webfetcher.py - Simple plugin usage
# 在 webfetcher.py - 简单插件使用
from plugins.curl_plugin import CurlPlugin

# That's it! No complex registry
# 就这样！无复杂注册表
PLUGINS = {
    'curl': CurlPlugin()
}

def fetch_with_plugins(url):
    # Try urllib first
    try:
        return fetch_with_urllib(url)
    except:
        # Simple fallback to curl for SSL
        if 'curl' in PLUGINS and PLUGINS['curl'].enabled:
            success, content, error = PLUGINS['curl'].fetch(url)
            if success:
                return content
    
    raise Exception("All methods failed")
```

### Week 2: Playwright Plugin (3 days)
### 第2周：Playwright插件（3天）

**Day 1-2: Basic implementation**
**第1-2天：基础实现**

```python
# plugins/playwright_plugin.py - No complexity
# plugins/playwright_plugin.py - 无复杂性
from plugins.base import SimplePlugin

class PlaywrightPlugin(SimplePlugin):
    def __init__(self):
        super().__init__('playwright')
        self.browser = None
        
    def can_fetch(self, url):
        # Only for sites that need JS
        # 仅用于需要JS的站点
        js_sites = ['xiaohongshu.com', 'xhslink.com']
        return any(site in url for site in js_sites)
    
    def fetch(self, url, timeout=30):
        try:
            from playwright.sync_api import sync_playwright
            
            with sync_playwright() as p:
                browser = p.chromium.launch(headless=True)
                page = browser.new_page()
                page.goto(url, timeout=timeout * 1000)
                content = page.content()
                browser.close()
                
                return True, content, None
        except Exception as e:
            return False, None, str(e)
```

**Day 3: Test and integrate**
**第3天：测试和集成**

### Week 3: Safari & Polish (4 days)
### 第3周：Safari和完善（4天）

**Day 1-2: Safari consolidation**
**第1-2天：Safari整合**

```python
# plugins/safari_plugin.py - macOS only
# plugins/safari_plugin.py - 仅macOS
import subprocess
import platform
from plugins.base import SimplePlugin

class SafariPlugin(SimplePlugin):
    def __init__(self):
        super().__init__('safari')
        self.enabled = platform.system() == 'Darwin'
        
    def fetch(self, url, timeout=30):
        if not self.enabled:
            return False, None, "Not on macOS"
            
        # Simple AppleScript execution
        # 简单AppleScript执行
        script = f'''
        tell application "Safari"
            open location "{url}"
            delay 2
            set pageSource to source of front document
            close front window
            return pageSource
        end tell
        '''
        
        try:
            result = subprocess.run(
                ['osascript', '-e', script],
                capture_output=True, text=True, timeout=timeout
            )
            return True, result.stdout, None
        except Exception as e:
            return False, None, str(e)
```

**Day 3-4: Final integration and testing**
**第3-4天：最终集成和测试**

## 4. Simple Configuration
## 4. 简单配置

```python
# config.py - Just Python, no YAML!
# config.py - 仅Python，无YAML！

# Plugin priorities (higher = try first)
# 插件优先级（更高=先尝试）
PLUGIN_PRIORITY = {
    'urllib': 100,  # Always first
    'safari': 80,   # Good for many sites  
    'curl': 50,     # SSL fallback
    'playwright': 30  # Last resort for JS
}

# Domain-specific overrides
# 域名特定覆盖
DOMAIN_PLUGINS = {
    'xiaohongshu.com': ['playwright', 'safari'],
    'githubusercontent.com': ['curl'],  # SSL issues
}

# Simple enable/disable
# 简单启用/禁用
ENABLED_PLUGINS = {
    'urllib': True,
    'curl': True,
    'playwright': False,  # Enable when needed
    'safari': platform.system() == 'Darwin'
}
```

## 5. Error Handling (Keep It Simple)
## 5. 错误处理（保持简单）

```python
def fetch_with_fallback(url):
    """Simple fallback chain"""
    """简单回退链"""
    
    errors = []
    
    # Get plugins for this domain
    domain = urlparse(url).netloc
    if domain in DOMAIN_PLUGINS:
        plugin_order = DOMAIN_PLUGINS[domain]
    else:
        # Sort by priority
        plugin_order = sorted(PLUGINS.keys(), 
                            key=lambda x: PLUGIN_PRIORITY.get(x, 0), 
                            reverse=True)
    
    # Try each plugin
    for plugin_name in plugin_order:
        if plugin_name not in PLUGINS:
            continue
            
        plugin = PLUGINS[plugin_name]
        if not plugin.enabled:
            continue
            
        try:
            success, content, error = plugin.fetch(url)
            if success:
                return content
            errors.append(f"{plugin_name}: {error}")
        except Exception as e:
            errors.append(f"{plugin_name}: {e}")
    
    # All failed
    raise Exception(f"All plugins failed: {'; '.join(errors)}")
```

## 6. Testing Strategy (Manual + Basic Auto)
## 6. 测试策略（手工+基础自动）

### Manual Testing Script
### 手工测试脚本

```python
# test_plugins.py - Simple test script
# test_plugins.py - 简单测试脚本

test_urls = [
    'https://httpbin.org/html',  # Basic
    'https://raw.githubusercontent.com/test/test/main/file.txt',  # SSL
    'https://www.xiaohongshu.com/explore',  # JS required
]

for url in test_urls:
    print(f"\nTesting: {url}")
    for plugin_name, plugin in PLUGINS.items():
        if plugin.can_fetch(url):
            success, content, error = plugin.fetch(url)
            print(f"  {plugin_name}: {'✓' if success else '✗'}")
            if error:
                print(f"    Error: {error[:50]}...")
```

### Basic Automated Tests
### 基础自动化测试

```python
# tests/test_basic.py
import unittest

class TestBasicFetch(unittest.TestCase):
    def test_urllib_basic(self):
        """Test basic urllib fetch"""
        content = fetch_with_fallback('https://httpbin.org/html')
        self.assertIn('<html>', content)
    
    def test_curl_ssl(self):
        """Test curl SSL fallback"""
        # Force curl by disabling urllib
        PLUGINS['urllib'].enabled = False
        content = fetch_with_fallback('https://github.com')
        self.assertIsNotNone(content)
        PLUGINS['urllib'].enabled = True
```

## 7. Migration Steps (Actual Commands)
## 7. 迁移步骤（实际命令）

### Step 1: Create plugin structure
### 步骤1：创建插件结构

```bash
# Create directories
mkdir -p plugins

# Create base plugin file
cat > plugins/base.py << 'EOF'
class SimplePlugin:
    def __init__(self, name):
        self.name = name
        self.enabled = True
    
    def can_fetch(self, url):
        return True
    
    def fetch(self, url, timeout=30):
        raise NotImplementedError
EOF

# Extract curl code (lines 1199-1253 from webfetcher.py)
# Copy and simplify into plugins/curl_plugin.py
```

### Step 2: Modify webfetcher.py
### 步骤2：修改webfetcher.py

```python
# At top of webfetcher.py, add:
try:
    from plugins.curl_plugin import CurlPlugin
    from plugins.playwright_plugin import PlaywrightPlugin
    from plugins.safari_plugin import SafariPlugin
    
    PLUGINS = {
        'curl': CurlPlugin(),
        'playwright': PlaywrightPlugin(),
        'safari': SafariPlugin()
    }
except ImportError:
    PLUGINS = {}  # Graceful degradation
    
# In fetch_html function, add plugin fallback:
if PLUGINS and 'SSL' in str(error):
    # Try curl for SSL issues
    if 'curl' in PLUGINS:
        success, content, _ = PLUGINS['curl'].fetch(url)
        if success:
            return content
```

### Step 3: Test incrementally
### 步骤3：增量测试

```bash
# Test each plugin individually
python -c "from plugins.curl_plugin import CurlPlugin; p = CurlPlugin(); print(p.fetch('https://httpbin.org/html')[0])"

# Test integration
python webfetcher.py 'https://httpbin.org/html'
```

## 8. What We're NOT Doing
## 8. 我们不做什么

### No Over-engineering
### 不过度工程化
- ❌ No complex plugin discovery
- ❌ No YAML configuration  
- ❌ No sandboxing or security layers
- ❌ No resource monitoring
- ❌ No plugin lifecycle management
- ❌ No event systems
- ❌ No dependency injection

### No Enterprise Features  
### 无企业级特性
- ❌ No multi-tenancy
- ❌ No role-based access
- ❌ No audit logging
- ❌ No distributed tracing
- ❌ No metrics dashboards
- ❌ No container orchestration

### Keep Using What Works
### 继续使用有效的部分
- ✓ Keep urllib as core (not a plugin)
- ✓ Keep existing retry logic
- ✓ Keep current API unchanged
- ✓ Keep webfetcher.py as main entry

## 9. Success Criteria (Simplified)
## 9. 成功标准（简化版）

### Must Have (Week 1)
### 必须有（第1周）
- [ ] Curl plugin works for SSL issues
- [ ] Can switch between urllib and curl
- [ ] No performance degradation

### Should Have (Week 2)
### 应该有（第2周）
- [ ] Playwright plugin for JS sites
- [ ] Basic plugin priority system
- [ ] Simple domain-based routing

### Nice to Have (Week 3)  
### 最好有（第3周）
- [ ] Safari plugin consolidated
- [ ] Basic error reporting
- [ ] Simple test coverage

## 10. Quick Win Implementation
## 10. 快速成功实施

### Today: Make curl work as plugin (2 hours)
### 今天：使curl作为插件工作（2小时）

```python
# 1. Create plugins/curl_plugin.py (copy lines 1199-1253)
# 2. Add to webfetcher.py:
from plugins.curl_plugin import CurlPlugin
curl = CurlPlugin()

# 3. In SSL error handler:
if "SSL" in str(e):
    success, content, _ = curl.fetch(url)
    if success:
        return content
        
# 4. Test:
python webfetcher.py 'https://raw.githubusercontent.com/test/test/main/README.md'
```

### Tomorrow: Clean up and test
### 明天：清理和测试

### This Week: Complete curl and playwright
### 本周：完成curl和playwright

## 11. Common Issues & Simple Fixes
## 11. 常见问题和简单修复

| Problem | Simple Fix |
|---------|-----------|
| SSL errors | Use curl with --insecure |
| Import errors | Static import with try/except |
| Plugin not found | Graceful degradation to urllib |
| Timeout issues | Simple timeout parameter |
| Memory leaks | Don't worry about it (personal tool) |

## 12. Final Notes
## 12. 最后说明

### This is YOUR tool
### 这是你的工具
- Make it work for YOUR needs
- Don't build for hypothetical users
- Optimize for YOUR workflow
- Fix problems when they actually occur

### Pragmatic Choices
### 务实选择
- Static > Dynamic
- Simple > Flexible
- Working > Perfect
- Now > Later

### Timeline Reality
### 时间线现实
- Week 1: Get curl working (core need)
- Week 2: Add playwright if needed
- Week 3: Clean up if time permits
- Total: 3 weeks maximum

---

**Document Version**: 1.0 (Personal Tool Focus)
**文档版本**: 1.0（个人工具聚焦）

**Key Differences from Enterprise Version**:
**与企业版本的关键差异**:
- Removed all sandboxing and security
- No dynamic plugin discovery
- No YAML configuration
- No complex error recovery
- No resource monitoring
- 3 weeks instead of 8-10 weeks
- Focus on working code over architecture