# 脚本采集方案（Selenium 优先版）

> 核心目标：将 Web_Fetcher 简化为“**Selenium + debuggerAddress** 主流程 + `urllib` 兜底”的双层结构，充分复用人工登录后的浏览器状态，确保对强登录、强风控站点实现 100% 抓取成功率。

---

## 0) 愿景与定位
- **Selenium 接管作为主力武器**：通过 `debuggerAddress` 连接模式，仅需三步（启动调试端口 → 人工登录 → Selenium 接管），即可完美复用 Cookie、LocalStorage、指纹、插件等所有会话信息。
- **`urllib` 作为轻量后备**：当页面无需登录/JS 渲染时，可直接使用 `urllib` 获取内容，节省资源。
- **其他插件（Playwright/Safari）转为可选**：保留但不强制启用，未来可按域名或场景选择性打开。

---

## 1) 新架构概览
```
CLI (wf.py)
  ↓ 传入 URL + --remote-debug / --remote-profile / --remote-wait
核心调度 (webfetcher.py)
  ↓
[优先] Selenium Remote Chrome Fetcher  ——> 输出 HTML → 解析→ Markdown
  ↓
[兜底] HTTP Fetcher (urllib + curl)
  ↓
[按需] Playwright / Safari 插件（默认禁用，可局部启用）
```

### 关键特性
- **极低改动成本**：Selenium 部分只需设置 `Options().debugger_address` 并调用 `webdriver.Chrome`，无须重写登录逻辑。
- **100% 状态复用**：人工登录后，所有站点私域内容、复杂指纹校验都可无缝获取。
- **反爬友好**：采用真实用户的浏览器进程，不触发常见自动化检测。
- **统一产出**：仍由现有解析层生成日期 + 标题的 Markdown，以及可选的 HTML、截图、元数据。

---

## 2) 组件职责调整
### 2.1 CLI （wf.py）
- 默认提示用户优先启动远程调试 Chrome，并提供命令示例。
- 新增/强化参数：
  - `--remote-debug HOST:PORT`（必传，若缺失可提示改用 `urllib-only` 模式）。
  - `--remote-profile PATH`
  - `--remote-wait SECONDS`
  - `--selenium-only`（跳过其他插件，加速链路）。
- 命令输出中明确当前抓取策略（Selenium / urllib）。

### 2.2 Selenium Remote Chrome Fetcher（新增主插件）
- `priority=HIGH`，在注册表中排在 HTTP 之前。
- `is_available()`：
  - 检查 Selenium 是否安装。
  - 检测指定调试端口的 `/json/version` 接口是否可达。
- `fetch()`：
  - 附着到已有 Chrome，执行 `driver.get(url)`。
  - 等待 `document.readyState == 'complete'`；可配置等待特定元素。
  - 可选执行截图，写入 `metadata`。
  - 只关闭 WebDriver 会话，不关浏览器窗口。
- 指标记录（`FetchMetrics`）：区分“Selenium-primary 成功/失败”。

### 2.3 HTTP Fetcher（urllib）
- 调整为次优，配置上移至 Selenium 失败后的兜底。
- 保持 curl fallback，以确保在无远程调试或 Selenium 不可用时仍有基础能力。

### 2.4 可选插件（Playwright / Safari）
- 默认在配置中标记为禁用。
- 对特定域名（如需要 headless 渲染或 Safari UA）时，可在 `domain_config.py` 局部启用。

---

## 3) 工作流详解
1. **用户准备阶段**
   - 一劳永逸：在日常使用的 Chrome 快捷方式中永久加入 `--remote-debugging-port=9222`，这样浏览器每日启动时即开启调试端口，完全不影响正常体验，脚本随时可接管。
   - 启动调试模式 Chrome：
     ```bash
     /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome \
       --remote-debugging-port=9222 \
       --user-data-dir="$HOME/.chrome-wf" \
       --no-first-run
     ```
   - 在该窗口完成登录、二次验证、必要的指纹操作。
2. **执行抓取**
   - 使用 `wf.py`：
     ```bash
     ./wf.py URL1 URL2 \
       --remote-debug 127.0.0.1:9222 \
       --remote-profile "$HOME/.chrome-wf" \
       --remote-wait 1.0 \
       --selenium-only
     ```
   - CLI 日志明确提示“正在通过 Selenium(debuggerAddress) 接管浏览器”。
3. **抓取流程**
   - Selenium 获取成功 → 页面 HTML 交给解析层，产出 Markdown。
   - Selenium 获取失败 → 自动切换至 `urllib`（并记录告警）。
   - 若 `--selenium-only` 未设置，可按配置继续尝试 Playwright/Safari。
4. **结果输出**
   - Markdown、原始 HTML、截图（如启用）、元数据 JSON。
   - 元数据中记录调试端口、profile 路径、等待策略、是否走了兜底。

---

## 4) 环境与依赖
- 在项目根目录维护统一虚拟环境 `.venv`：
  ```bash
  python3 -m venv .venv
  source .venv/bin/activate
  pip install --upgrade pip wheel setuptools
  pip install selenium
  pip install -r tasks/dev_requirements.txt  # 包含 beautifulsoup4、playwright（可选）等
  ```
- 初次运行前，执行 `playwright install chromium` 仅在需要 JS 兜底时再安装。
- `tasks/dev_requirements.txt` 中锁定 selenium 版本，确保团队一致。

---

## 5) 日志与监控
- **日志级别**
  - `INFO`：标记策略选择（Selenium / urllib）、成功/失败状态。
  - `WARNING`：提示调试端口不可用、会话失效、等待元素超时。
  - `DEBUG`：输出详细的 Selenium 附着参数、加载耗时、最终 URL。
- **指标补充**
  - 在 `FetchMetrics` 中新增字段：`selenium_debugger_used`、`debugger_address`、`profile_path`。
  - 统计成功率，便于评估 Selenium 主流程的稳定性。

---

## 6) 风险与对策
| 风险 | 描述 | 对策 |
| --- | --- | --- |
| 调试端口未开启或被占用 | Selenium 无法接管 | CLI 运行前提供 `wf doctor --remote-debug 9222` 预检；日志给出替代端口建议 |
| 登录态过期 | 返回登录页或 302 | 解析层检测到登录页关键元素 → 提示用户重新登录，再次执行 |
| Selenium 版本不兼容 | 驱动启动报错 | 在依赖文件中锁定版本， README 中提供升级指南 |
| 资源未回收 | 浏览器实例过多占用内存 | 插件层设置最长等待与超时清理；文档提示用户定期关闭旧实例 |

---

## 7) 推进路线图
1. **阶段 A：文档与配置**
   - 更新 README/CLI 帮助，强调 Selenium 主流程。
   - 在配置中默认启用 Selenium 插件，禁用 Playwright/Safari。
2. **阶段 B：实现与测试**
   - 实现 `remote_chrome_fetcher` 插件及 CLI 参数。
   - 补充单元测试（模拟调试端口、失败回退、成功抓取）。
3. **阶段 C：试点与迭代**
   - 针对 1~2 个强登录站点运行端到端验证，收集指标。
   - 根据反馈微调等待策略、截图支持、日志提示。
4. **阶段 D：收敛与清理**
   - 根据使用情况决定是否完全停用 Playwright/Safari。
   - 更新自动化脚本、CI 流程，确保 Selenium 依赖被正确安装。

---

## 8) 操作清单（速查）
- [ ] 启动带调试端口的 Chrome 并完成人工登录。
- [ ] 激活项目虚拟环境，确认安装 `selenium`。
- [ ] 运行 `wf.py` 并传入 `--remote-debug` 参数。
- [ ] 检查 `output/` 下的 Markdown、HTML、截图是否齐全。
- [ ] 若遇到失败，查看日志提示并重新登录或切换端口。

---

## 9) 常见问题（FAQ）
- **Q：没有图形界面怎么办？**
  - A：该方案依赖真实浏览器，需在本地或有 GUI 的环境运行。无界面服务器请使用隧道转发或保持 Playwright 兜底。
- **Q：可以多开不同站点的会话吗？**
  - A：可以。启动多个 Chrome 调试实例，使用不同的 `--user-data-dir`，在 CLI 中为每组 URL 指定相应的 `--remote-debug` 与 `--remote-profile`。
- **Q：如何快速确认端口可用？**
  - A：访问 `http://127.0.0.1:9222/json/version`，看到 JSON 即表示调试接口正常。

---

## 10) 后续支持
- 需要我进一步编写 `remote_chrome_fetcher` 插件骨架、CLI 参数处理或测试样例，可在下一任务中直接提出，我会基于本方案继续协助。
